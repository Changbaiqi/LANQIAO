package lanqiao;

public class 最大连通 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		char map[][] = {
				"110010000011111110101001001001101010111011011011101001111110".toCharArray(),
				"010000000001010001101100000010010110001111100010101100011110".toCharArray(),
				"001011101000100011111111111010000010010101010111001000010100".toCharArray(),
				"101100001101011101101011011001000110111111010000000110110000".toCharArray(),
				"010101100100010000111000100111100110001110111101010011001011".toCharArray(),
				"010011011010011110111101111001001001010111110001101000100011".toCharArray(),
				"101001011000110100001101011000000110110110100100110111101011".toCharArray(),
				"101111000000101000111001100010110000100110001001000101011001".toCharArray(),
				"001110111010001011110000001111100001010101001110011010101110".toCharArray(),
				"001010101000110001011111001010111111100110000011011111101010".toCharArray(),
				"011111100011001110100101001011110011000101011000100111001011".toCharArray(),
				"011010001101011110011011111010111110010100101000110111010110".toCharArray(),
				"001110000111100100101110001011101010001100010111110111011011".toCharArray(),
				"111100001000001100010110101100111001001111100100110000001101".toCharArray(),
				"001110010000000111011110000011000010101000111000000110101101".toCharArray(),
				"100100011101011111001101001010011111110010111101000010000111".toCharArray(),
				"110010100110101100001101111101010011000110101100000110001010".toCharArray(),
				"110101101100001110000100010001001010100010110100100001000011".toCharArray(),
				"100100000100001101010101001101000101101000000101111110001010".toCharArray(),
				"101101011010101000111110110000110100000010011111111100110010".toCharArray(),
				"101111000100000100011000010001011111001010010001010110001010".toCharArray(),
				"001010001110101010000100010011101001010101101101010111100101".toCharArray(),
				"001111110000101100010111111100000100101010000001011101100001".toCharArray(),
				"101011110010000010010110000100001010011111100011011000110010".toCharArray(),
				"011110010100011101100101111101000001011100001011010001110011".toCharArray(),
				"000101000101000010010010110111000010101111001101100110011100".toCharArray(),
				"100011100110011111000110011001111100001110110111001001000111".toCharArray(),
				"111011000110001000110111011001011110010010010110101000011111".toCharArray(),
				"011110011110110110011011001011010000100100101010110000010011".toCharArray(),
				"010011110011100101010101111010001001001111101111101110011101".toCharArray()
		};
		
		boolean state[][] = new boolean[map.length][map[0].length];
		boolean tt[][] = new boolean[map.length][map[0].length];
		
		int max =0;
		
		for(int y =0; y < map.length ; ++y) {
			for(int x =0 ; x < map[y].length ; ++x) {
				SS co = new SS(0);
				dfs(co,map,state,x,y,1);
				max = Math.max(co.getMaxAns(), max);
			}
		}
		System.out.println(max);
		
		
	}
	
	
	
	public static void dfs(SS co,char map[][],boolean state[][],int startX,int startY,int ans) {
		if(co.getMaxAns()<ans)
			co.setMaxAns(ans);
		
		int next[][] = {
				{startX,startY-1},
				{startX,startY+1},
				{startX-1,startY},
				{startX+1,startY-1}
		};
		
		
		for(int i = 0; i < next.length ; ++i ) {
			if(next[i][0]<0 || next[i][1]<0 || next[i][0]>=state[0].length || next[i][1]>=state.length)
				continue;
			
			if(state[next[i][1]][next[i][0]] || map[next[i][1]][next[i][0]]!='1')
				continue;
			
			state[next[i][1]][next[i][0]]=true;
			dfs(co,map,state,next[i][0],next[i][1],ans+1);
		}
	}
	
	
	

}
class SS{
	int maxAns =0;

	public SS(int maxAns) {
		super();
		this.maxAns = maxAns;
	}


	public int getMaxAns() {
		return maxAns;
	}

	public void setMaxAns(int maxAns) {
		this.maxAns = maxAns;
	}
	
}


